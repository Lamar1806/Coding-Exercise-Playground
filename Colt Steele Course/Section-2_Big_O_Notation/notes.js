/*
    Generalized labels to how fast code is running!

    numbers based of slide number
*/

/*
5. Timing Our code
    Suppose we want to Write a function that 
    calculates the sum of all numbers from 1 up to
    (and including) some number n.

    //time isn't always the most effience way to know 
    //which function is best
    //if time differance is small and running
    //if people are using diffrent machinees

    add1.js
    add2.js
*/

/*
6. Counting Operations
    If not time, then what?
    Rather than conting secconds,
    wicha are so variable... 
    Let's count the number of simple operations
    the computer has to perform!

    including multiplication, addition, subtraction
*/

/*
8. Official Intro to Big O
    It allows us to talke formally about how 
    the runtime of an algorithm grows as the 
    inputs grow.

    we say that an algorithm is O(f(n)) if the
    number of simple operations the computer has to do
    is eventually less than a constant f(n), as n increases

    *f(n) could be linear (fn = n)
    *fn could be quadratic (fn = n^2)
    *fn could be constant fn = 1
    *fn could be something entirerly diffrent

    
*/
